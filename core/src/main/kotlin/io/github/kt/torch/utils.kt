package io.github.kt.torch

import io.github.kt.torch.ndarray.*
import io.github.kt.torch.tensor.*
import io.github.kt.torch.util.*
import io.github.kt.torch.util.cuda.*
import java.lang.management.*

fun KTTorch.contentEquals(a: Tensor, n: Number): Boolean = NDArrays.contentEquals(a, n)
fun KTTorch.contentEquals(a: Tensor, b: Tensor): Boolean = NDArrays.contentEquals(a, b)
fun KTTorch.shapeEquals(a: Tensor, b: Tensor): Boolean = NDArrays.shapeEquals(a, b)
fun KTTorch.allClose(a: Tensor, b: Tensor): Boolean = NDArrays.allClose(a, b)
fun KTTorch.allClose(a: Tensor, b: Tensor, rtol: Double, atol: Double, equalNan: Boolean): Boolean = NDArrays.allClose(a, b, rtol, atol, equalNan)
fun KTTorch.eq(a: Tensor, n: Number): Tensor = NDArrays.eq(a, n)
fun KTTorch.eq(n: Number, a: Tensor): Tensor = NDArrays.eq(n, a)
fun KTTorch.eq(a: Tensor, b: Tensor): Tensor = NDArrays.eq(a, b)
fun KTTorch.neq(a: Tensor, n: Number): Tensor = NDArrays.neq(a, n)
fun KTTorch.neq(n: Number, a: Tensor): Tensor = NDArrays.neq(n, a)
fun KTTorch.neq(a: Tensor, b: Tensor): Tensor = NDArrays.neq(a, b)
fun KTTorch.gt(a: Tensor, n: Number): Tensor = NDArrays.gt(a, n)
fun KTTorch.gt(n: Number, a: Tensor): Tensor = NDArrays.gt(n, a)
fun KTTorch.gt(a: Tensor, b: Tensor): Tensor = NDArrays.gt(a, b)
fun KTTorch.gte(a: Tensor, n: Number): Tensor = NDArrays.gte(a, n)
fun KTTorch.gte(n: Number, a: Tensor): Tensor = NDArrays.gte(n, a)
fun KTTorch.gte(a: Tensor, b: Tensor): Tensor = NDArrays.gte(a, b)
fun KTTorch.lt(a: Tensor, n: Number): Tensor = NDArrays.lt(a, n)
fun KTTorch.lt(n: Number, a: Tensor): Tensor = NDArrays.lt(n, a)
fun KTTorch.lt(a: Tensor, b: Tensor): Tensor = NDArrays.lt(a, b)
fun KTTorch.lte(a: Tensor, n: Number): Tensor = NDArrays.lte(a, n)
fun KTTorch.lte(n: Number, a: Tensor): Tensor = NDArrays.lte(n, a)
fun KTTorch.lte(a: Tensor, b: Tensor): Tensor = NDArrays.lte(a, b)
fun KTTorch.where(condition: Tensor, a: Tensor, b: Tensor): Tensor = NDArrays.where(condition, a, b)
fun KTTorch.maximum(a: Tensor, n: Number): Tensor = NDArrays.maximum(a, n)
fun KTTorch.maximum(n: Number, a: Tensor): Tensor = NDArrays.maximum(n, a)
fun KTTorch.maximum(a: Tensor, b: Tensor): Tensor = NDArrays.maximum(a, b)
fun KTTorch.minimum(a: Tensor, n: Number): Tensor = NDArrays.minimum(a, n)
fun KTTorch.minimum(n: Number, a: Tensor): Tensor = NDArrays.minimum(n, a)
fun KTTorch.minimum(a: Tensor, b: Tensor): Tensor = NDArrays.minimum(a, b)
fun KTTorch.booleanMask(data: Tensor, index: Tensor): Tensor = NDArrays.booleanMask(data, index)
fun KTTorch.booleanMask(data: Tensor, index: Tensor, axis: Int): Tensor = NDArrays.booleanMask(data, index, axis)
fun KTTorch.sequenceMask(data: Tensor, sequenceLength: Tensor): Tensor =  NDArrays.sequenceMask(data, sequenceLength)
fun KTTorch.sequenceMask(data: Tensor, sequenceLength: Tensor, value: Float): Tensor = NDArrays.sequenceMask(data, sequenceLength, value)
fun KTTorch.add(a: Tensor, n: Number): Tensor = NDArrays.add(a, n)
fun KTTorch.add(n: Number, a: Tensor): Tensor = NDArrays.add(n, a)
fun KTTorch.add(vararg tensors: Tensor): Tensor = NDArrays.add(*tensors)
fun KTTorch.sub(a: Tensor, n: Number): Tensor = NDArrays.sub(a, n)
fun KTTorch.sub(n: Number, a: Tensor): Tensor = NDArrays.sub(n, a)
fun KTTorch.sub(a: Tensor, b: Tensor): Tensor = NDArrays.sub(a, b)
fun KTTorch.mul(a: Tensor, n: Number): Tensor = NDArrays.mul(a, n)
fun KTTorch.mul(n: Number, a: Tensor): Tensor = NDArrays.mul(n, a)
fun KTTorch.mul(vararg tensors: Tensor): Tensor = NDArrays.mul(*tensors)
fun KTTorch.div(a: Tensor, n: Number): Tensor = NDArrays.div(a, n)
fun KTTorch.div(n: Number, a: Tensor): Tensor = NDArrays.div(n, a)
fun KTTorch.div(a: Tensor, b: Tensor): Tensor = NDArrays.div(a, b)
fun KTTorch.pow(a: Tensor, n: Number): Tensor = NDArrays.pow(a, n)
fun KTTorch.pow(n: Number, a: Tensor): Tensor = NDArrays.pow(n, a)
fun KTTorch.pow(a: Tensor, b: Tensor): Tensor = NDArrays.pow(a, b)
fun KTTorch.mod(a: Tensor, n: Number): Tensor = NDArrays.mod(a, n)
fun KTTorch.mod(n: Number, a: Tensor): Tensor = NDArrays.mod(n, a)
fun KTTorch.mod(a: Tensor, b: Tensor): Tensor = NDArrays.mod(a, b)
fun KTTorch.addi(a: Tensor, n: Number): Tensor = NDArrays.addi(a, n)
fun KTTorch.addi(n: Number, a: Tensor): Tensor = NDArrays.addi(n, a)
fun KTTorch.addi(vararg tensors: Tensor): Tensor = NDArrays.addi(*tensors)
fun KTTorch.subi(a: Tensor, n: Number): Tensor = NDArrays.subi(a, n)
fun KTTorch.subi(n: Number, a: Tensor): Tensor = NDArrays.subi(n, a)
fun KTTorch.subi(a: Tensor, b: Tensor): Tensor = NDArrays.subi(a, b)
fun KTTorch.muli(a: Tensor, n: Number): Tensor = NDArrays.muli(a, n)
fun KTTorch.muli(n: Number, a: Tensor): Tensor = NDArrays.muli(n, a)
fun KTTorch.muli(vararg tensors: Tensor): Tensor = NDArrays.muli(*tensors)
fun KTTorch.divi(a: Tensor, n: Number): Tensor = NDArrays.divi(a, n)
fun KTTorch.divi(n: Number, a: Tensor): Tensor = NDArrays.divi(n, a)
fun KTTorch.divi(a: Tensor, b: Tensor): Tensor = NDArrays.divi(a, b)
fun KTTorch.modi(a: Tensor, n: Number): Tensor = NDArrays.modi(a, n)
fun KTTorch.modi(n: Number, a: Tensor): Tensor = NDArrays.modi(n, a)
fun KTTorch.modi(a: Tensor, b: Tensor): Tensor = NDArrays.modi(a, b)
fun KTTorch.powi(a: Tensor, n: Number): Tensor = NDArrays.powi(a, n)
fun KTTorch.powi(n: Number, a: Tensor): Tensor = NDArrays.powi(n, a)
fun KTTorch.powi(a: Tensor, b: Tensor): Tensor = NDArrays.powi(a, b)
fun KTTorch.dot(a: Tensor, b: Tensor): Tensor = NDArrays.dot(a, b)
fun KTTorch.matMul(a: Tensor, b: Tensor): Tensor = NDArrays.matMul(a, b)
fun KTTorch.stack(tensors: TensorList): Tensor = NDArrays.stack(tensors)
fun KTTorch.stack(tensors: TensorList, axis: Int): Tensor = NDArrays.stack(tensors, axis)
fun KTTorch.concat(tensors: TensorList): Tensor = NDArrays.concat(tensors)
fun KTTorch.concat(tensors: TensorList, axis: Int): Tensor = NDArrays.concat(tensors, axis)
fun KTTorch.logicalAnd(a: Tensor, b: Tensor): Tensor = NDArrays.logicalAnd(a, b)
fun KTTorch.logicalOr(a: Tensor, b: Tensor): Tensor = NDArrays.logicalOr(a, b)
fun KTTorch.logicalXor(a: Tensor, b: Tensor): Tensor = NDArrays.logicalXor(a, b)
fun KTTorch.erfinv(input: Tensor): Tensor = NDArrays.erfinv(input)
fun KTTorch.erf(input: Tensor): Tensor = NDArrays.erf(input)
fun KTTorch.hasCuda(): Boolean = CudaUtils.hasCuda()
fun KTTorch.gpuCount(): Int = CudaUtils.getGpuCount()
fun KTTorch.cudaVersion(): Int = CudaUtils.getCudaVersion()
fun KTTorch.cudaVersionString(): String = CudaUtils.getCudaVersionString()
fun KTTorch.computeCapability(device: Int): String = CudaUtils.getComputeCapability(device)
fun KTTorch.gpuMemory(device: Device): MemoryUsage = CudaUtils.getGpuMemory(device)
fun KTTorch.manualSeed(seed: Long) = RandomUtils.RANDOM.setSeed(seed)
fun KTTorch.random(): Double = RandomUtils.random()
fun KTTorch.nextGaussian(): Double = RandomUtils.nextGaussian()
fun KTTorch.nextInt(): Int = RandomUtils.nextInt()
fun KTTorch.nextInt(bound: Int): Int = RandomUtils.nextInt(bound)
fun KTTorch.nextFloat(): Float = RandomUtils.nextFloat()
fun KTTorch.nextFloat(lower: Float, upper: Float): Float = RandomUtils.nextFloat(lower, upper)
fun KTTorch.hasNeuron(): Boolean = NeuronUtils.hasNeuron()
fun KTTorch.neuronCores(): Int = NeuronUtils.getNeuronCores()
fun KTTorch.neuronDevices(location: String): List<String> = NeuronUtils.getNeuronDevices(location)
fun KTTorch.neuronCoresForDevice(device: String): Int = NeuronUtils.getNeuronCoresForDevice(device)